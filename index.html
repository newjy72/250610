<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì§€ë¢°ì°¾ê¸° ê²Œì„</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }

    #controls {
      margin: 10px;
    }

    #board {
      display: inline-grid;
      margin-top: 10px;
      gap: 2px;
    }

    .cell {
      width: 30px;
      height: 30px;
      background-color: #ccc;
      text-align: center;
      vertical-align: middle;
      line-height: 30px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
    }

    .cell.open {
      background-color: #eee;
      cursor: default;
    }

    .cell.mine {
      background-color: red;
      color: white;
    }

    .cell.flag {
      background-color: yellow;
    }
  </style>
</head>
<body>
  <h1>ì§€ë¢°ì°¾ê¸°</h1>

  <div id="controls">
    ë‚œì´ë„:
    <select id="difficulty">
      <option value="easy">ì‰¬ì›€ (8x8, 10ê°œ)</option>
      <option value="medium">ì¤‘ê°„ (12x12, 20ê°œ)</option>
      <option value="hard">ì–´ë ¤ì›€ (16x16, 40ê°œ)</option>
    </select>
    <button onclick="startGame()">ë‹¤ì‹œ ì‹œì‘</button>
    <p>â±ï¸ ê²½ê³¼ ì‹œê°„: <span id="timer">0</span>ì´ˆ</p>
  </div>

  <div id="board"></div>

  <script>
    const boardEl = document.getElementById("board");
    const timerEl = document.getElementById("timer");
    const difficultyEl = document.getElementById("difficulty");

    let board = [];
    let timer = 0;
    let timerInterval = null;
    let gameOver = false;
    let size = 8;
    let mineCount = 10;

    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [ 0, -1],          [ 0, 1],
      [ 1, -1], [ 1, 0], [ 1, 1],
    ];

    function startGame() {
      // ë‚œì´ë„ ì„¤ì •
      const difficulty = difficultyEl.value;
      if (difficulty === "easy") {
        size = 8; mineCount = 10;
      } else if (difficulty === "medium") {
        size = 12; mineCount = 20;
      } else {
        size = 16; mineCount = 40;
      }

      // ì´ˆê¸°í™”
      board = [];
      boardEl.innerHTML = "";
      timer = 0;
      timerEl.textContent = timer;
      gameOver = false;
      clearInterval(timerInterval);

      boardEl.style.gridTemplateColumns = `repeat(${size}, 30px)`;

      // ë³´ë“œ ìƒì„±
      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cell = {
            x, y,
            mine: false,
            revealed: false,
            flagged: false,
            element: document.createElement("div")
          };
          cell.element.classList.add("cell");
          cell.element.addEventListener("click", () => onClick(cell));
          cell.element.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            onRightClick(cell);
          });
          boardEl.appendChild(cell.element);
          board[y][x] = cell;
        }
      }

      // ì§€ë¢° ë°°ì¹˜
      let placed = 0;
      while (placed < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        if (!board[y][x].mine) {
          board[y][x].mine = true;
          placed++;
        }
      }

      // íƒ€ì´ë¨¸ ì‹œì‘
      timerInterval = setInterval(() => {
        timer++;
        timerEl.textContent = timer;
      }, 1000);
    }

    function onClick(cell) {
      if (gameOver || cell.revealed || cell.flagged) return;

      cell.revealed = true;
      cell.element.classList.add("open");

      if (cell.mine) {
        cell.element.classList.add("mine");
        cell.element.textContent = "ğŸ’£";
        endGame(false);
      } else {
        const count = countMinesAround(cell.x, cell.y);
        if (count > 0) {
          cell.element.textContent = count;
        } else {
          // ì£¼ë³€ ì…€ ì—´ê¸°
          directions.forEach(([dx, dy]) => {
            const nx = cell.x + dx;
            const ny = cell.y + dy;
            if (isInBounds(nx, ny)) {
              onClick(board[ny][nx]);
            }
          });
        }
        checkWin();
      }
    }

    function onRightClick(cell) {
      if (gameOver || cell.revealed) return;

      cell.flagged = !cell.flagged;
      cell.element.classList.toggle("flag");
      cell.element.textContent = cell.flagged ? "ğŸš©" : "";
    }

    function countMinesAround(x, y) {
      let count = 0;
      directions.forEach(([dx, dy]) => {
        const nx = x + dx;
        const ny = y + dy;
        if (isInBounds(nx, ny) && board[ny][nx].mine) {
          count++;
        }
      });
      return count;
    }

    function isInBounds(x, y) {
      return x >= 0 && y >= 0 && x < size && y < size;
    }

    function endGame(won) {
      clearInterval(timerInterval);
      gameOver = true;
      board.flat().forEach(cell => {
        if (cell.mine) {
          cell.element.classList.add("mine");
          cell.element.textContent = "ğŸ’£";
        }
      });
      alert(won ? "ğŸ‰ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!" : "ğŸ’¥ ê²Œì„ ì˜¤ë²„!");
    }

    function checkWin() {
      const allSafeRevealed = board.flat().every(cell =>
        (cell.mine || cell.revealed)
      );
      if (allSafeRevealed) {
        endGame(true);
      }
    }

    // ì‹œì‘ ì‹œ ê¸°ë³¸ ê²Œì„ ì‹¤í–‰
    startGame();
  </script>
</body>
</html>
